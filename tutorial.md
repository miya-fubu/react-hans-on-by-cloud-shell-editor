# ゼロから始める React ハンズオン

## はじめに

本ガイドは、JavaScript(以下 JS)を初めて触る人を対象とした React ハンズオンです。

本ガイドを修了することで、2015 年以降の比較的モダンな JS で記載する React を学ぶことができます。

---

**注意**

本ガイドでは、2015 年以前の旧仕様の JS や React を使用しない Web ページの作成方法については触れません。

## Node.js のインストール

まずは Node.js をインストールしましょう

Node.js はサーバーサイドの JS 実行環境です。

本来 JS は、ブラウザ上で動作することを目的として開発された言語です。ですが、ライブラリの適応や各種ブラウザで動作できるようにコードを変換するためには、JS のサーバーサイド実行環境が必要となります。

現在、一般的なサーバーサイド JS 実行環境は Node.js と Deno の 2 種が存在します。
Deno の方がより最新のものですが、安定稼働するとは言い難く、未だ Node.js が一般的なツールとして認識されているため、Deno を使用する必然性がない限りは Node.js の利用を推奨します。

Cloud Shell を開いて、以下のコマンドを入力してください。

<walkthrough-open-cloud-shell-button></walkthrough-open-cloud-shell-button>

```bash
sudo apt install nodejs
```

install ができましたら以下のコマンドを入力して、コードが動作することを確認してください。

```bash
node -v
```

## 最新の Node.js をインストールする

Node.js の[公式ページ](https://nodejs.org/ja/)を確認してください。

確認するとわかると思いますが、インストールした Node.js よりもメジャーバージョンがかなり進んでいることがわかるかと思います。

そのため、最新版の Node.js を入手するために別途コマンドを入力する必要があります。

方法としては、以下の二つが挙げられます。

- a. NodeSource が提供する Node.js 公式のバイナリディストリビューション
- b. バージョンマネージャ

## a. NodeSource が提供する Node.js 公式のバイナリディストリビューション

Github 上に存在する公式の Node.js ディストリビューションを適応して、apt 経由でインストールできるようにします。

各バージョンのインストール方法については、[こちら](https://github.com/nodesource/distributions/blob/master/README.md#installation-instructions)を参照してください。

## b. バージョンマネージャ

a の場合は手軽にアップデートが行えるという利点がありますが、下位バージョンへの切り替えが面倒というデメリットが存在します。
開発環境では、こちらの利用を推奨します。

Node.js のパッケージマネージャとして有名なものは以下の二つです。

- n
- nvm

今回は、 `nvm` を用いて最新版の Node.js をインストールします。

---

### nvm の Github を確認する

コマンドを入力する前に、nvm のバージョンを確認します。
[こちら](https://github.com/nvm-sh/nvm)のリンクより、nvm の github を確認してください

### nvm をインストールする

バージョンを控えたら、以下のコマンドを入力してください。
コマンド内の`{version}`は任意の値に書き換えてください

```bash
wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/{version}/install.sh | bash
```

### nvm を使用して、最新の Node.js をインストール

nvm は、最新版と lts に alias が振られています。
任意のバージョンを以下のコマンドのどちらかを使用してインストールしてください

```bash
nvm install node
```

```bash
nvm install --lts
```

また、以下のようにして任意のバージョンをインストールすることもできます。

```bash
nvm install v16.13.0
```

## 1 章. 基礎文法を学ぶ

この章では、JS の基礎文法を学びます。

章の終わりでは、実践演習として、既存のファイルを編集して FizzBuzz を実装していただきます。

## 1-1. 変数宣言

まず、変数宣言の方法を確認します。
まず初めに、<walkthrough-editor-open-file filepath="./section1_base_syntax/variable.js">こちら</walkthrough-editor-open-file>をクリックして練習用のファイルを開いてください。

## 1-1-1. 変数宣言

開いたファイルの内容は、変数 foo と変数 bar の中身をコンソール上で実行するというものです。さっそく実行してみましょう。

editor 上部にある terminal から、新しいターミナルを開き以下のコマンドを実行してください。

```bash
node section1_base_syntax/variable.js
```

コマンドを実行後、以下の文章が表示されれば成功です。

```
I'm Pen
No, you are Tom
```

英語の教科書で見る一般的な例文です。
このことから、`let`,`const` で変数を宣言するということが分かったかと思います。

## 1-1-2 let と const の違い

この二つの違いを理解するために、実際に値を変化させてみましょう。
Tom が自身が Pen ではなく Tom だということを理解したので、変数 `foo` の中身を `I'm Tom` に変更します。

3 行目に以下のコードを書き足してください。

```javascript
foo = "I'm Tom";
```

再び、ターミナルから以下のコマンドを実行します。

```bash
node section1_base_syntax/variable.js
```

すると、表示内容がいかに変化したかと思います。

```
I'm Tom
No, you are Tom
```

これで、 `foo` の中身を書き換えることができました。

それでは、foo を書き換えたことにより文章がおかしくなってしまったので、今度は変数 `bar` の中身を書き換えましょう。

4 行目に以下のコードを書き足してください。

```
bar = 'Yes, you are Tom'
```

そして、ターミナルから以下のコマンドを実行します。

```bash
node section1_base_syntax/variable.js
```

すると今度は以下のエラーが出てしまったかと思います。

```
section1_base_syntax/variable.js:4
bar = 'Yes, you are Tom'
    ^
TypeError: Assignment to constant variable.
```

これが、let と const の違いです。

## 1-1-3. const とは何か

`const`は、再代入が行えない変数宣言です。

再代入とは、先ほど行った一度宣言した変数に別の値を挿入する動作を指します。

一方で`let`は再代入が行える変数宣言です。
先ほど確認できたように、`const`と`let`で動作が異なったのはこの仕様の違いが原因です。

昨今のフロントエンド界隈では、原則として`const`の使用を推奨することが多いです。
これは、以下の一度宣言した string 型や number 型の値が、宣言後に別の値に変化していないことが保証されているためです。

言葉だけでは理解が難しいかと思いますので、<walkthrough-editor-open-file filepath="./section1_base_syntax/deficult_ex.js">例題用のファイル</walkthrough-editor-open-file>を用意しました。

対象のファイルを見て、瞬時に変数 bar の値が何かを読み取ることは難しいかと思います。
もちろん数秒あれば読み取ることは可のですが、これがより実践的なファイルであれば、より長く時間がかかること、場合によっては読み間違えることは十分に考えられるでしょう。

const の場合、それが string 型や number 型である限りは、宣言した際の値と同じ値が入っていることが保証されているため、瞬時に変数の中身を読み取ることができます。

こうしたことから、原則として `const` を使うことが勧められています。

---

なお、注意点として、 `const` は定数ではないということに注意してください。
あくまで、再代入が行えないだけです。例えば、`Array.pop()`や`Array.push()`を用いた配列操作などは再代入には当たらないため、たとえ`const`であっても値を書き換えることが可能です。

## 1-2. テンプレートリテラル

一般に、多くのプログラミング言語において、変数の含まれた文字列を表現する場合、以下のような書き方をします。

```javascript
const text = "変数文字列";
const longText =
  "こうやって" + text + "を組み込みます\n改行はこうして改行します";
```

この書き方は、変数が組み込まれていることは理解しやすいですが、複数の変数を組み込む場合は、可読性に問題があるという欠点を抱えていました。

テンプレートリテラルは、この読みにくい文字列の生成を阻む形で生まれた文字列表現方法です。あまり呼ばれることはありませんが、テンプレート文字列と呼ばれることもあります。

例えば、上記のテキストはテンプレートリテラルでは以下のように表現することができます。

```javascript
const text = "変数文字列";
const longText = `こうやって${text}を組み込みます
改行はこうして改行します`;
```

こうして文章中に直接変数を書くことができるようになることで、可読性が高まっていることがわかるかと思います。

なお、上記の例のように改行も改行コードではなく改行で行うことが可能ですが、フォーマッタの関係でこちらを利用することは多くありません。

## 1-3. 関数

ここでは、一般的な関数の書き方と、アロー関数、即時実行関数について解説します。

<walkthrough-editor-open-file filepath="./section1_base_syntax/functions.js">こちら</walkthrough-editor-open-file>のページを開いてください。

## 1-3-1. function

まず、今開いているファイルを以下のコマンドで実行してみてください。

```bash
node ./section1_base_syntax/functions.js
```

すると、以下のような文章が表示されるかと思います。

```
I'm Pen
No, you are Tom
```

それでは、今実行したコードの解説を行います。

このコードでは、コンソール上にテキストを表示する機能を持った `print関数` に引数としてテキストを渡すことで、テキストをコンソール上に表示しています。

関数を作成しているのは、コードの 4 行目、 `function` という文字が書き込まれている箇所になります。

これは、変数の let や const と同じく関数を宣言する場合のキーワードで、以下のようなフォーマットで書き込むと、関数を作成することができます。

```
function(引数) {式}
```

先ほどの例の場合は、引数に `tom` と `friend` が、式に `console.log() * 2` が該当します。

なお、注意点として、function を用いた関数は、同名の関数の再宣言が可能です。
もし再宣言を個なってしまった場合、後に書いた関数が優先されます。

## 1-3-2. デフォルト引数

Python を書いた方は理解しやすいと思いますが、関数には初期値を持たせることができます。
この初期値のことをデフォルト引数と呼びます。

```
function print(tom, friend = 'yes, you are pen'){
    console.log(tom)
    console.log(friend)
}
```

例として、先ほどのファイルの 4 行目から 7 行目を上記の書き方に書き換え、かつ 9 行目の第二引数を削除した場合、以下のような結果が表示されます。

```
I'm Pen
yes, you are pen
```

この書き方をすると、変数宣言時に本来必須のはずの第二引数を省略することができます。
省略した場合、第二引数として与えたデフォルト引数が使用されます。

## 1-3-3. 関数式

関数には、関数式と呼ばれる書き方も存在します。

開いているファイルの 4 行目から 7 行目を下記の書き方に置き換え、再度実行してみてください。

```javascript
const print = function (tom, friend) {
  console.log(tom);
  console.log(friend);
};
```

実行した結果、先ほどと同じ結果が表示されたかと思います。

この書き方は関数式と言って、無名関数というものを変数として宣言することで、従来の関数と同じように取り扱うことができます。
通常の関数ではあまり使用されない書き方なのですが、後述するアロー関数にてこの書き方は必須となるので覚えていてください。

## 1-3-4. アロー関数

アロー関数を使用することで、無名関数を簡単に書くことができます。

この書き方が生まれてから、関数は基本的にアロー関数で書かれることになりました。

現在では、関数を書く場合は何か特別な理由が存在しない限り、基本的にこのアロー関数で関数は記載されます。

## 1-3-5. アロー関数の書き方

<walkthrough-editor-open-file filepath="./section1_base_syntax/arrowFunctions.js">こちら</walkthrough-editor-open-file>のファイルを開いてください

これは、先ほどの関数をアロー関数を用いて書き換えたものです。

アロー関数は、以下のようなフォーマットで記載します。

```javascript
const 関数名 = (引数) => {
  式;
};
```

見てわかるように、アロー関数は関数式を用いて関数を表現します。

また、必ず関数式であることから、意図しない再宣言を回避することができることがわかるかと思います。

また、今回は複数行の処理を行う必要があったために書くことができませんでしたが、もし単一業の場合は次のように一行で書くことが可能です。

```javascript
const 関数名 = (引数) => 式;
```

この場合、式の結果が関数の返り値になることに注意してください。

さらに、引数が一つしかない場合、以下のように引数のカッコを外すことが可能です。

```javascript
const 関数名 = (引数) => 式;
```

ここまでアロー関数は通常の関数と同じように動作すると書いてきましたが、一点大きく挙動が異なるものがあります。
それは、関数内で使用する This の挙動です。

ただし、こちらに関しては気にしなくても問題ありません。むしろ気にしないでください。

This というものが存在するということは知っておいてもよいですが、使おうとしないでください。

This の挙動を気にする場合というのは、必然的に純粋ではない関数を作成しようとしているということになります。

純粋な関数というのは、引数の値のみから式の値を算出する関数のことで、これを意識することには以下の利点が存在します。

1. テストが簡潔に済む
2. 別のことを実装する場合に、グローバル汚染を考慮せずに済む
3. ロジック以外に処理順を考慮せずに済む

This はグローバルオブジェクトとなるケースが存在するため、使い方によっては意図しない動作を生むことがあります。

可能な限り this を使用しないコードを記載し、純粋な関数であることに努めてください。

## 1-3-6. 即時実行関数

Python におけるラムダ式のように、関数として宣言することなく関数を使用できると便利なケースがあると思います。

即時実行関数は、ラムダ式と同様にその場で関数を作成、使用できる便利な書き方です。即時関数と呼ばれることもあります。

```javascript
(function (仮引数) {
  式;
})(実引数)
  // ↓ アロー関数の場合
((仮引数) => {
  式;
})(実引数);
```

一般用途ではあまり使用しませんが、何かしらの処理を書き捨てる際に非同期処理 (API を叩くなど) を書く場合、この無記名関数をほぼ必ず使用します。

## 1-4. 条件分岐とループ処理

条件分岐では `if` と `switch/case文` 、ループ処理の項では `while` , `for...in...` , `for...of...` , `array.forEach`, `array.map` に触れます。

## 1-4-1. if 文

ご存じ条件分岐です。以下のように記載します。

```javascript
if (boolean値を返す式) {
  式の結果が true の場合に行う処理
}
```

ここで注意したいのは、結果が true となる値についてです。
JS には、暗黙の型変換というものが存在し、本来別の型が存在する場所に別の型の値が存在する場合、その型へのキャストを行うという特性があります。

例えば、以下のように動作します。

```javascript
const foo = (args) => {
  if (args) {
    return args;
  } else {
    return "false";
  }
};

const alpha = foo("5" + 1); // 51 (string)
const beta = foo("5" - 1); // 4 (number)
const gamma = foo("a" - 1); // "false" (string)
/*
  Number("a") === NaN で NaN-1 は NaN, Boolean(NaN) === falseのため、
  if文のelseの先に行き "false" を返した
*/
```

ここで true となるのは、以下に示す値**ではないもの**が該当します。

| 値        | 意味                                                            |
| --------- | --------------------------------------------------------------- |
| false     | Boolean 値の false                                              |
| 0         | 数値の 0                                                        |
| -0        | 数値のマイナス 0                                                |
| 0n        | bigint 型 の値 0 (Big int ととらえるとわかりやすいかと思います) |
| ""        | 空文字                                                          |
| null      | 値がない状態                                                    |
| undefined | 値が代入されていない変数の返り値、未定義                        |
| NaN       | int 型の値。Not a Number。Number("Foo") の結果などが該当します  |

この表からわかるように、例えば `"false"` (Strig 値)は `true` (boolean 値)です。
同様に、 `"0"` も `true` となります。

JS ではこの暗黙の型変換が原因でバグが生じることが度々あるため、これら Falsy な値(キャストした結果 false となる値のこと) は必ず覚えるようにしてください。

また、複数の条件分岐は以下のように書きます。

```javascript
if (0) {
  console.log("");
} else if ("") {
  console.log("");
} else {
  console.log("else if");
}
```

## 1-4-2. 三項演算子

if 文の短縮記法として三項演算子が存在します。
JS の三項演算子は、以下のように記載します。

```Javascript
const foo = boolean値を返す式 ? trueの場合の値 : falseの場合の値
```

## 1-4-3. switch / case 文

if 文と比較すると使用することは多くありませんが、まれに使用することがあるのが case 文です。

一部のコーディングガイドでは、if 文の else if の回数を制限しているものがあり、可読性の観点から複数行の else if を敬遠する考え方も存在しています。

多くの条件分岐を必要とする場合、case 文を用いるとよいでしょう。

```javascript
const testSwitch = (args) => {
  let alpha = "";
  switch (args) {
    case 0:
    case `hoge`:
      return "0 or hoge";
    case "bar":
      alpha = "bar";
      break;
    default:
      alpha = "defo";
  }
  return alpha;
};

console.log(testSwitch(0)); // '0 or hoge'
console.log(testSwitch("bar")); // 'bar'
console.log(testSwitch("beta")); // 'defo'
```

## 1-4-4. ループ

Loopを行いたいケースはいろいろあるかと思いますが、参考までに用途別に使用されやすいキーワードをまとめました

|要件 |キーワード|
|---|---|
|規定回数のループがしたい| while, array.map, array.forEach|
|配列の値を基にループがしたい| array.map, array.forEach|
|無限ループ|while|

見てわかるかと思いますが、forが使用されることは稀です。
一般的な `for(変数宣言; 条件式; 変数更新){式}` のループを見ることはまずないでしょう。

これは個人的な見解ですが、array.mapがReactで使われやすいせいか、なんとなくLoop処理ではarray.mapをよく見かける傾向にあります。

また、 `for...of...` , `for...in...` は処理を混同しやすく、その二つが求める処理内容をmapはカバーしきることができるというのも要因の一つでしょう。

個人的には、可読性の観点からもarrayのインスタンスメソッドを使用してのループを心がけることをお勧めします。

## 1-4-5. while文

while文は主に無限ループに使用されがちなキーワードです。

以下のようなフォーマットで記載します。

```
while(boolean値を返す条件式){式}
```

見ての通り、for文などに比べて簡潔に記載できるため、単純な条件式を採用している場合はよく使用されます。
単純な条件式の代表格としては、無限ループが挙げられます。

以下のコードを見てください。

```javascript
while (1){
  if (foo.status==200){
    break
  }

  console.log(foo)
}
```

while文の条件に `1` が記載されています。
1は当然trueなので、このループは無限に続きます。
こういった呼び出すたびに値が変わる値をループさせる際にこの書き方はよく使用されます。

また、稀によく以下のようなコードも目にします。

```javascript
const loop = (count) => {
  while (count--){
    console.log(count)
  }
}
loop(10)
```

このコードは、ループされるごとにcountの数が1ずつ減少し、最終的に 0 (Boolean(0) == false) となってloopを抜け出すという処理です。
特定の回数だけループさせたいといった処理を行う場合、 `for` よりもかなり短いコードで実装できるため、こういった処理を書くことがあります。

なお、一部のコーディングスタイルガイドでは、引数への代入を禁止していて上記のコードが許されないこともあります。

## 1-4-6. map, forEach

この二つは、array (配列) のインスタンスメソッドとして組み込まれている処理です。

対象の配列を一つ一つに分解し、それぞれに処理を行うという用途で使用されます。

両社の違いはいくつかありますが、最も大きな違いはその返り値で、`map`は配列を返すのに対し`forEach`は何も返しません。

```javascript

const sampleLits = ["alpha", "beta", "gamma"];

console.log(sampleList.forEach(item => item.split("")[0])) // undefined
console.log(sampleList.map(item => item.split("")[0])) // ["a","b","g"]

```

Reactでは配列操作の需要がそれなりにあるので、特に `map` は非常に多用されます。

## 1-5. デストラクチャリングとスプレッド構文

ここでは、Reactでは必須知識と言っていいデストラクチャリングとスプレッド構文について話します。

今までのものは何となく検索が可能でしたが、今から話す二つについては検索エンジンからの検索が困難であるため、最低でも名前だけは覚えるようにしてください。

## 1-5-1. デストラクチャリング

デストラクチャリングは、配列や連想配列から選択的に値を取得する機能です。分割代入とも呼ばれます。

主に引数から値を取得する際に多用されます。

```javascript
const func = ({text}) => {
  console.log(text)
}
const keywords = {
  text: "foo"
}

func(keywords)
// "foo"
```

上記の例では一つでしたが、複数の値を取得することも可能です。

分割代入なしに引数を使用する場合に比べて、記述量を減らす、あるいは何を引数として取得しているかを明瞭にできるメリットがあります。

また、今回は連想配列を例に行いましたが、当然配列でも同様の操作が可能です。

## 1-5-2. スプレッド構文

Reactに限らず、このスプレッド構文はJavascriptの一般的な配列操作方法として使用されます。

ぱっと見ではなかなか理解しにくいのですが、簡単に言うと、対象の配列をバラバラに切り出すという機能です。

それほど多くはないのですが、JSでは配列や連想配列の標準メソッドには配列の順序を直接操作するものがあります。

そういった場合に、元の値を残して配列の値を操作したい場合に配列のコピーを作成する必要があるのですが、通常の操作でその操作を行うことは少々面倒な記載が必要となります。

スプレッド構文は、そうした場合に重宝します。

```javascript
const foo = ["f", "o", "o"];
const foo2 = [...foo];
// アルファベット逆順操作
foo2.sort((first, second) => {
  if (first > second) return -1;
  else if (first < second) return 1;
  return 0;
});
console.log(foo);
// ["f","o","o"]
console.log(foo2);
// ["o","o","f"]
```

上記の例では、sort関数が配列を直接操作する関数であるため、元の配列fooが並び変えられないようにfooの代わりとなる配列foo2を作成しています。

また、分割代入使用時にもスプレッド構文は便利です。

```javascript
const bar = {
  text: "bar",
  number: 2,
  description: "this is second meta syntactic text"
}
const print = ({ text, ...args }) => {
  console.log(text)
  console.log(args)
}
print(bar)
// bar
// { number: 2, description: 'this is second meta syntactic text' }
```

上記のように、スプレッド構文を用いることで分割代入を用いて取得した引数の余りを取得することが可能です。


## 1-6. 非同期処理

非同期処理とは、文字通り処理を 非 同期的に処理する仕組みのことです。

現在行っている処理を終えてから次の行の処理を実行することを同期処理と言い、いままで触れてきた処理は全てこの同期処理に該当します。

ブラウザ上での実行が主であるJSは、サーバーとの通信機会が多く、そのたびに処理を長時間停止させていては問題が生じます。非同期処理は、そういった長時間掛かる処理を実行時に待機せず、そのまま先の処理を実行します。

---

### 身近な非同期処理例

身近な非同期処理の例としては、ブラウジングの際によく目にする検索候補があります。

普段Google等の検索エンジンを用いて何かを検索する際、テキストボックスに文字を入力すると、その下に検索候補一覧を出現させる処理が働くかと思います。

これは、テキストボックスへの入力が一息ついた段階で、ブラウザが非同期的にサーバーへ検索候補を問い合わせ、その結果を検索ボックスの下部に表示しています。

もしこの際に同期的に処理が行われていたのであれば、検索候補の表示を待機している間、他のJSが一切動かなくなってしまいます。

## 1-6-1. 非同期処理を実装する

今回はnode.js環境下で処理を実装していますが、一旦ブラウザ上で処理を実装しているとしてお話をします。

一般に、ブラウザ上での動作で非同期処理の対象となるのは、サーバーサイドとの通信処理です。
サーバーサイド側との通信は、対象のサーバーの処理能力もそうですが、そのサーバーとの通信環境によってその処理時間は大きく左右されます。
通信するデータ量と通信環境によっては、分単位の時間がかかってしまってもおかしくはないでしょう。

その間他の処理をしないわけにもいかないので、JSではこの処理は非同期処理として実装されるのが一般的です。

JS組み込みのサーバーサイドとの通信処理メソッドとして、 `fetch()` 関数があります。

それでは、試しにローカル上に立てたサーバーと通信してデータを非同期的に取得してみましょう

## 1-7. 演習
<!-- TODO: fizbuzの実装 -->
